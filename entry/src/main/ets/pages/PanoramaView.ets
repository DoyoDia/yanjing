/**
 * PanoramaView - å…¨æ™¯æ¸²æŸ“è§†å›¾é¡µé¢ï¼ˆä¸»æ§åˆ¶é¡µé¢ï¼‰
 * ä½¿ç”¨ XComponent æ‰¿è½½ OpenGL ES æ¸²æŸ“çš„ 360Â° å…¨æ™¯
 * æ”¯æŒè§†é¢‘æ’­æ”¾å’Œå¤–éƒ¨æ˜¾ç¤ºå™¨è¾“å‡º
 * ä½¿ç”¨ md360player åº“è¿›è¡Œå…¨æ™¯è§†é¢‘æ¸²æŸ“
 */

import { SensorManager, SensorDataListener, DeviceHoldMode, getSensorManager } from '../sensor/SensorManager';
import { GlassesImuManager, GlassesConnectionState, getGlassesImuManager } from '../sensor/GlassesImuManager';
import { Quaternion, Matrix4 } from '../utils/MathUtils';
import { SensorListenerImpl, ExternalDisplayListenerImpl, GlassesImuListenerImpl } from '../utils/ListenerImplementations';
import { ExternalDisplayManager, DisplayInfo, ExternalDisplayListener, DisplayType, getExternalDisplayManager } from '../display/ExternalDisplayManager';
import { common } from '@kit.AbilityKit';
import { picker } from '@kit.CoreFileKit';
import { MDVRLibrary, IOnSurfaceReadyCallback, Context } from '@ohos/md360player';
import { media } from '@kit.MediaKit';

/**
 * è§†é¢‘æ’­æ”¾å›è°ƒå®ç°ç±»
 * å®ç° IOnSurfaceReadyCallback æ¥å£ï¼Œç”¨äº md360player åº“
 */
class VideoCallback implements IOnSurfaceReadyCallback {
  private avPlayer: media.AVPlayer | null = null;
  private videoUri: string = '';
  private surfaceId: string | null = null;
  private progressTimer: number | null = null;
  private onStateChanged: ((isPlaying: boolean) => void) | null = null;
  private onProgressChanged: ((currentTime: number, duration: number) => void) | null = null;

  setStateCallback(onStateChanged: (isPlaying: boolean) => void, 
                   onProgressChanged: (currentTime: number, duration: number) => void): void {
    this.onStateChanged = onStateChanged;
    this.onProgressChanged = onProgressChanged;
  }

  onSurfaceReady(surface: Object): void {
    console.log('VideoCallback: Surface ready');
  }

  async setSurfaceIdAndCreatePlayer(surfaceId: string): Promise<void> {
    if (!surfaceId || surfaceId === '0' || surfaceId === '') {
      console.error('VideoCallback: Invalid surfaceId:', surfaceId);
      return;
    }

    if (this.surfaceId === surfaceId) {
      console.log('VideoCallback: surfaceId already set:', surfaceId);
      return;
    }

    this.surfaceId = surfaceId;
    console.log('VideoCallback: Creating AVPlayer with surfaceId:', surfaceId);

    try {
      if (this.avPlayer !== null) {
        await this.avPlayer.release();
        this.avPlayer = null;
      }

      this.avPlayer = await media.createAVPlayer();
      if (this.avPlayer === null) {
        console.error('VideoCallback: Failed to create AVPlayer');
        return;
      }

      this.avPlayer.surfaceId = surfaceId;

      this.avPlayer.on('stateChange', (state: string) => {
        console.log('VideoCallback: AVPlayer state changed to:', state);
        if (state === 'playing') {
          this.onStateChanged?.(true);
          this.startProgressTimer();
        } else if (state === 'paused' || state === 'stopped') {
          this.onStateChanged?.(false);
          this.stopProgressTimer();
        }
      });

      if (this.videoUri) {
        this.avPlayer.url = this.videoUri;
      }

      console.log('VideoCallback: AVPlayer created successfully');
    } catch (error) {
      console.error('VideoCallback: Failed to create AVPlayer:', error);
    }
  }

  async setSource(uri: string): Promise<void> {
    this.videoUri = uri;
    if (this.avPlayer) {
      try {
        await this.avPlayer.reset();
        this.avPlayer.url = uri;
      } catch (error) {
        console.error('VideoCallback: Failed to set source:', error);
      }
    }
  }

  async play(): Promise<void> {
    if (this.avPlayer && (this.avPlayer.state === 'prepared' || this.avPlayer.state === 'paused')) {
      try {
        await this.avPlayer.play();
      } catch (error) {
        console.error('VideoCallback: Failed to play:', error);
      }
    }
  }

  async pause(): Promise<void> {
    if (this.avPlayer && this.avPlayer.state === 'playing') {
      try {
        await this.avPlayer.pause();
      } catch (error) {
        console.error('VideoCallback: Failed to pause:', error);
      }
    }
  }

  isPlaying(): boolean {
    return this.avPlayer?.state === 'playing';
  }

  private startProgressTimer(): void {
    this.stopProgressTimer();
    this.progressTimer = setInterval(() => {
      if (this.avPlayer && this.avPlayer.state === 'playing') {
        const currentTime = this.avPlayer.currentTime || 0;
        const duration = this.avPlayer.duration || 0;
        this.onProgressChanged?.(currentTime, duration);
      }
    }, 500);
  }

  private stopProgressTimer(): void {
    if (this.progressTimer !== null) {
      clearInterval(this.progressTimer);
      this.progressTimer = null;
    }
  }

  release(): void {
    this.stopProgressTimer();
    if (this.avPlayer) {
      this.avPlayer.release();
      this.avPlayer = null;
    }
  }
}

@Entry
@Component
struct PanoramaView {
  // XComponent æ§åˆ¶å™¨
  private xComponentController: XComponentController = new XComponentController();

  // ç®¡ç†å™¨å®ä¾‹
  private sensorManager: SensorManager = getSensorManager();
  private displayManager: ExternalDisplayManager = getExternalDisplayManager();
  private glassesManager: GlassesImuManager = getGlassesImuManager();

  // md360player ç›¸å…³
  private vrLibrary: MDVRLibrary | null = null;
  private vrContext: Context | null = null;
  private videoCallback: VideoCallback | null = null;

  // ä¸Šä¸‹æ–‡
  private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;

  // æ¸²æŸ“çŠ¶æ€
  @State isRendering: boolean = false;
  @State rendererReady: boolean = false;

  // FOV è®¾ç½®
  private readonly fovMin: number = 60;
  private readonly fovMax: number = 110;
  private readonly fovStep: number = 1;
  @State fovValue: number = 90;

  // è§†é¢‘çŠ¶æ€
  @State isPlaying: boolean = false;
  @State videoProgress: number = 0;
  @State videoDuration: number = 0;
  @State videoFileName: string = 'æœªé€‰æ‹©è§†é¢‘';

  // å¤–éƒ¨æ˜¾ç¤ºå™¨çŠ¶æ€
  @State hasExternalDisplay: boolean = false;
  @State externalDisplayInfo: string = 'æœªè¿æ¥';
  @State isOutputToExternal: boolean = false;

  // çœ¼é•œ IMU çŠ¶æ€
  @State glassesConnected: boolean = false;
  @State glassesStreaming: boolean = false;
  @State glassesName: string = 'æœªçŸ¥è®¾å¤‡';

  // å¸§ç‡ç»Ÿè®¡
  @State fps: number = 0;
  private frameCount: number = 0;
  private lastFpsTime: number = 0;

  // è§¦æ§æ‰‹åŠ¿
  private lastPanX: number | undefined = undefined;
  private lastPanY: number | undefined = undefined;

  // ç›‘å¬å™¨å®ä¾‹
  private sensorListener: SensorListenerImpl | null = null;
  private displayListener: ExternalDisplayListenerImpl | null = null;
  private glassesListener: GlassesImuListenerImpl | null = null;

  /**
   * é¡µé¢å³å°†å‡ºç°
   */
  aboutToAppear(): void {
    // åˆ›å»ºä¼ æ„Ÿå™¨ç›‘å¬å™¨
    this.sensorListener = new SensorListenerImpl((quaternion: Quaternion, viewMatrix: Matrix4) => {
      if (this.vrLibrary && this.rendererReady) {
        // å°†ä¼ æ„Ÿå™¨æ•°æ®ä¼ é€’ç»™ md360player
        // md360player ä½¿ç”¨å››å…ƒæ•° (x, y, z, w) è¿›è¡Œè§†è§’æ§åˆ¶
        const quat = quaternion.toArray();
        this.vrLibrary.updateGyroData(quat[0], quat[1], quat[2], quat[3]);
      }
    });

    // åˆ›å»ºå¤–éƒ¨æ˜¾ç¤ºå™¨ç›‘å¬å™¨
    this.displayListener = new ExternalDisplayListenerImpl(
      (displayInfo: DisplayInfo) => {
        this.hasExternalDisplay = true;
        this.externalDisplayInfo = `${displayInfo.name} (${displayInfo.width}x${displayInfo.height})`;
        console.info('PanoramaView: External display connected');
      },
      (displayId: number) => {
        this.hasExternalDisplay = this.displayManager.hasExternalDisplay();
        if (!this.hasExternalDisplay) {
          this.externalDisplayInfo = 'æœªè¿æ¥';
          this.isOutputToExternal = false;
        }
        console.info('PanoramaView: External display disconnected');
      },
      (displayInfo: DisplayInfo) => {
        if (displayInfo.type === DisplayType.EXTERNAL) {
          this.externalDisplayInfo = `${displayInfo.name} (${displayInfo.width}x${displayInfo.height})`;
        }
      }
    );

    // Glasses IMU listener
    this.glassesListener = new GlassesImuListenerImpl(
      (state: GlassesConnectionState) => {
        this.glassesConnected = state.connected && state.hasPermission;
        this.glassesStreaming = state.streaming;
        this.glassesName = state.deviceInfo ? state.deviceInfo.name : 'Unknown';

        if (this.isRendering) {
          if (state.connected && state.hasPermission) {
            this.sensorManager.stop();
            this.glassesManager.startImu();
          } else {
            this.glassesManager.stopImu();
            this.sensorManager.start();
          }
        }
      },
      (quaternion: Quaternion) => {
        this.sensorManager.updateFromQuaternion(quaternion);
      },
      (message: string) => {
        console.error('PanoramaView: Glasses IMU error', message);
      }
    );

    // é…ç½®ä¼ æ„Ÿå™¨
    this.sensorManager.configure({
      samplingInterval: 16666667,
      holdMode: DeviceHoldMode.LANDSCAPE_TELESCOPE
    });

    // æ·»åŠ ç›‘å¬å™¨
    this.sensorManager.addListener(this.sensorListener);
    this.displayManager.addListener(this.displayListener);
    if (this.glassesListener) {
      this.glassesManager.addListener(this.glassesListener);
    }

    // è®¾ç½®ä¸Šä¸‹æ–‡
    this.displayManager.setContext(this.context);

    this.glassesManager.initialize();

    // åˆå§‹åŒ–ç®¡ç†å™¨
    this.initializeManagers();
  }

  /**
   * é¡µé¢å³å°†æ¶ˆå¤±
   */
  aboutToDisappear(): void {
    this.stopRendering();
    this.sensorManager.stop();
    
    if (this.sensorListener) {
      this.sensorManager.removeListener(this.sensorListener);
    }
    if (this.displayListener) {
      this.displayManager.removeListener(this.displayListener);
    }
    if (this.glassesListener) {
      this.glassesManager.removeListener(this.glassesListener);
    }
    
    this.glassesManager.stopImu();
    this.glassesManager.stopMonitoring();
    this.displayManager.closeExternalWindow();
    
    // é‡Šæ”¾ md360player èµ„æº
    if (this.videoCallback) {
      this.videoCallback.release();
      this.videoCallback = null;
    }
    if (this.vrLibrary) {
      this.vrLibrary.onDestroy();
      this.vrLibrary = null;
    }
  }

  /**
   * åˆå§‹åŒ–ç®¡ç†å™¨
   */
  private async initializeManagers(): Promise<void> {
    // åˆå§‹åŒ–å¤–éƒ¨æ˜¾ç¤ºå™¨ç®¡ç†å™¨
    await this.displayManager.initialize();
    this.hasExternalDisplay = this.displayManager.hasExternalDisplay();

    if (this.hasExternalDisplay) {
      const extDisplay = this.displayManager.getFirstExternalDisplay();
      if (extDisplay) {
        this.externalDisplayInfo = `${extDisplay.name} (${extDisplay.width}x${extDisplay.height})`;
      }
    }
  }

  /**
   * åˆå§‹åŒ– VR åº“
   */
  private async initVR(surfaceId: string): Promise<void> {
    console.info('PanoramaView: Initializing VR with surfaceId:', surfaceId);

    // åˆ›å»ºè§†é¢‘å›è°ƒ
    this.videoCallback = new VideoCallback();
    this.videoCallback.setStateCallback(
      (isPlaying: boolean) => {
        this.isPlaying = isPlaying;
      },
      (currentTime: number, duration: number) => {
        this.videoProgress = currentTime;
        this.videoDuration = duration;
      }
    );

    // åˆ›å»º VR Context
    this.vrContext = new Context();

    // æ„å»º MDVRLibrary
    const builder = MDVRLibrary.with(this.vrContext)
      .displayMode(MDVRLibrary.DISPLAY_MODE_NORMAL)
      .interactiveMode(MDVRLibrary.INTERACTIVE_MODE_MOTION_WITH_TOUCH)
      .asVideo(this.videoCallback);

    this.vrLibrary = builder.build(this.xComponentController);

    // é€šçŸ¥ Surface å°±ç»ª
    this.vrLibrary.onSurfaceReady(surfaceId);

    // è·å–è§†é¢‘ Surface ID å¹¶åˆ›å»ºæ’­æ”¾å™¨
    setTimeout(async () => {
      if (!this.vrLibrary || !this.videoCallback) {
        return;
      }

      const videoSurfaceId = this.vrLibrary.getVideoSurfaceId();
      console.info('PanoramaView: Got video surfaceId:', videoSurfaceId);

      if (videoSurfaceId && videoSurfaceId !== '' && videoSurfaceId !== '0') {
        await this.videoCallback.setSurfaceIdAndCreatePlayer(videoSurfaceId);
        this.rendererReady = true;
        console.info('PanoramaView: Renderer ready');
      } else {
        console.error('PanoramaView: Invalid video surfaceId');
      }
    }, 500);
  }

  /**
   * å¼€å§‹æ¸²æŸ“å¾ªç¯
   */
  private startRendering(): void {
    if (this.isRendering) return;

    this.isRendering = true;
    if (this.glassesConnected) {
      this.glassesManager.startImu();
    } else {
      this.sensorManager.start();
    }
    this.lastFpsTime = Date.now();
    this.frameCount = 0;
  }

  /**
   * åœæ­¢æ¸²æŸ“å¾ªç¯
   */
  private stopRendering(): void {
    this.isRendering = false;
    this.glassesManager.stopImu();
    this.sensorManager.stop();
  }

  /**
   * é€‰æ‹©è§†é¢‘æ–‡ä»¶
   */
  private async selectVideo(): Promise<void> {
    try {
      const documentViewPicker = new picker.DocumentViewPicker(this.context);
      const uris = await documentViewPicker.select({
        maxSelectNumber: 1,
        selectMode: picker.DocumentSelectMode.FILE,
        fileSuffixFilters: ['.mp4', '.mov', '.webm', '.avi']
      });

      if (uris.length > 0) {
        const videoUri = uris[0];
        const parts = videoUri.split('/');
        this.videoFileName = parts[parts.length - 1] || 'è§†é¢‘æ–‡ä»¶';

        if (this.videoCallback) {
          await this.videoCallback.setSource(videoUri);
        }
        console.info('PanoramaView: Video selected', videoUri);
      }
    } catch (error) {
      console.error('PanoramaView: Failed to select video', JSON.stringify(error));
    }
  }

  /**
   * æ’­æ”¾/æš‚åœè§†é¢‘
   */
  private async toggleVideoPlayback(): Promise<void> {
    if (!this.videoCallback) {
      return;
    }

    if (this.videoCallback.isPlaying()) {
      await this.videoCallback.pause();
    } else {
      await this.videoCallback.play();
    }
  }

  /**
   * åˆ‡æ¢å¤–éƒ¨æ˜¾ç¤ºå™¨è¾“å‡º
   */
  private async toggleExternalOutput(): Promise<void> {
    if (!this.hasExternalDisplay) {
      console.warn('PanoramaView: No external display available');
      return;
    }

    if (this.isOutputToExternal) {
      await this.displayManager.closeExternalWindow();
      this.isOutputToExternal = false;
    } else {
      const extDisplay = this.displayManager.getFirstExternalDisplay();
      if (extDisplay) {
        const windowResult = await this.displayManager.createWindowOnExternalDisplay(
          extDisplay.id,
          'pages/ExternalPanoramaView'
        );
        this.isOutputToExternal = windowResult !== null;
      }
    }
  }

  /**
   * XComponent åŠ è½½å®Œæˆå›è°ƒ
   */
  private async onXComponentLoad(): Promise<void> {
    console.info('PanoramaView: XComponent loaded');

    const surfaceId = this.xComponentController.getXComponentSurfaceId();
    await this.initVR(surfaceId);
  }

  /**
   * XComponent é”€æ¯å›è°ƒ
   */
  private onXComponentDestroy(): void {
    console.info('PanoramaView: XComponent destroyed');
    this.rendererReady = false;
    this.stopRendering();
  }

  /**
   * åº”ç”¨å½“å‰ FOV
   */
  private applyFov(): void {
    // md360player çš„ FOV æ§åˆ¶ç”±å†…éƒ¨å¤„ç†ï¼Œè¿™é‡Œä¿ç•™æ¥å£ä»¥å¤‡åç»­æ‰©å±•
    console.info('PanoramaView: FOV set to', this.fovValue);
  }

  /**
   * æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
   */
  private formatTime(ms: number): string {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }

  build() {
    Stack() {
      // å…¨æ™¯æ¸²æŸ“è§†å›¾
      XComponent({
        id: 'panoramaXComponent',
        type: XComponentType.SURFACE,
        libraryname: 'md360player',
        controller: this.xComponentController
      })
        .onLoad(() => this.onXComponentLoad())
        .onDestroy(() => this.onXComponentDestroy())
        .width('100%')
        .height('100%')
        .gesture(
          PanGesture({ fingers: 1, direction: PanDirection.All, distance: 1 })
            .onActionStart((event: GestureEvent) => {
              this.lastPanX = event.offsetX;
              this.lastPanY = event.offsetY;
            })
            .onActionUpdate((event: GestureEvent) => {
              if (this.lastPanX !== undefined && this.lastPanY !== undefined && this.vrLibrary) {
                const distanceX = event.offsetX - this.lastPanX;
                const distanceY = event.offsetY - this.lastPanY;
                this.vrLibrary.onDrag(distanceX, distanceY);
                this.lastPanX = event.offsetX;
                this.lastPanY = event.offsetY;
              }
            })
            .onActionEnd(() => {
              this.lastPanX = undefined;
              this.lastPanY = undefined;
            })
        )

      // æ§åˆ¶é¢æ¿
      Column() {
        // é¡¶éƒ¨çŠ¶æ€æ 
        Row() {
          // æ¸²æŸ“çŠ¶æ€
          Row() {
            Circle()
              .width(10)
              .height(10)
              .fill(this.isRendering ? '#4CAF50' : '#757575')
            Text(this.isRendering ? 'LIVE' : 'PAUSED')
              .fontSize(12)
              .fontColor('#FFFFFF')
              .margin({ left: 6 })
          }
          .padding({ left: 12, right: 12, top: 6, bottom: 6 })
          .backgroundColor('rgba(0, 0, 0, 0.6)')
          .borderRadius(16)

          Blank()

          // å¤–éƒ¨æ˜¾ç¤ºå™¨çŠ¶æ€
          // Glasses IMU status
          Row() {
            Circle()
              .width(10)
              .height(10)
              .fill(this.glassesConnected ? (this.glassesStreaming ? '#4CAF50' : '#FFC107') : '#757575')
            Text(this.glassesConnected ? `${this.glassesName} IMU` : 'IMU Disconnected')
              .fontSize(12)
              .fontColor(this.glassesConnected ? '#4CAF50' : '#757575')
              .margin({ left: 6 })
          }
          .padding({ left: 12, right: 12, top: 6, bottom: 6 })
          .backgroundColor('rgba(0, 0, 0, 0.6)')
          .borderRadius(16)

          Blank()

          // FPS
          Text(`${this.fps} FPS`)
            .fontSize(12)
            .fontColor('#FFFFFF')
            .padding({ left: 12, right: 12, top: 6, bottom: 6 })
            .backgroundColor('rgba(0, 0, 0, 0.6)')
            .borderRadius(16)
        }
        .width('100%')
        .padding(12)

        Blank()

        // åº•éƒ¨æ§åˆ¶é¢æ¿
        Column() {
          // è§†é¢‘ä¿¡æ¯æ 
          Row() {
            Text(`ğŸ“¹ ${this.videoFileName}`)
              .fontSize(12)
              .fontColor('#B0BEC5')
              .maxLines(1)
              .textOverflow({ overflow: TextOverflow.Ellipsis })
              .layoutWeight(1)

            Text(`${this.formatTime(this.videoProgress)} / ${this.formatTime(this.videoDuration)}`)
              .fontSize(12)
              .fontColor('#78909C')
          }
          .width('100%')
          .padding({ left: 16, right: 16, top: 8, bottom: 8 })

          // è§†é¢‘è¿›åº¦æ¡
          if (this.videoDuration > 0) {
            Progress({
              value: this.videoProgress,
              total: this.videoDuration,
              type: ProgressType.Linear
            })
              .width('90%')
              .height(4)
              .color('#2196F3')
              .margin({ bottom: 12 })
          }

          // æ§åˆ¶æŒ‰é’®ç¬¬ä¸€è¡Œï¼ˆè§†é¢‘æ§åˆ¶ï¼‰
          Row() {
            Button('ğŸ“‚ é€‰æ‹©è§†é¢‘')
              .fontSize(13)
              .height(40)
              .layoutWeight(1)
              .backgroundColor('rgba(33, 150, 243, 0.8)')
              .margin({ right: 8 })
              .onClick(() => this.selectVideo())

            Button(this.isPlaying ? 'â¸ æš‚åœ' : 'â–¶ æ’­æ”¾')
              .fontSize(13)
              .height(40)
              .layoutWeight(1)
              .backgroundColor(this.isPlaying ?
                'rgba(255, 152, 0, 0.8)' : 'rgba(76, 175, 80, 0.8)')
              .onClick(() => this.toggleVideoPlayback())
          }
          .width('90%')
          .margin({ bottom: 8 })

          // æ§åˆ¶æŒ‰é’®ç¬¬äºŒè¡Œï¼ˆæ¸²æŸ“æ§åˆ¶ï¼‰
          Row() {
            Button(this.isRendering ? 'â¹ åœæ­¢æ¸²æŸ“' : 'â–¶ å¼€å§‹æ¸²æŸ“')
              .fontSize(13)
              .height(40)
              .layoutWeight(1)
              .backgroundColor(this.isRendering ?
                'rgba(244, 67, 54, 0.8)' : 'rgba(76, 175, 80, 0.8)')
              .onClick(() => {
                if (this.isRendering) {
                  this.stopRendering();
                } else {
                  this.startRendering();
                }
              })
          }
          .width('90%')
          .margin({ bottom: 8 })

          // FOV æ»‘å—
          Column() {
            Text(`ğŸ”­ FOV ${this.fovValue}Â°`)
              .fontSize(12)
              .fontColor('#B0BEC5')
              .margin({ bottom: 6 })

            Slider({
              value: this.fovValue,
              min: this.fovMin,
              max: this.fovMax,
              step: this.fovStep
            })
              .width('90%')
              .onChange((value: number) => {
                this.fovValue = Math.round(value);
                this.applyFov();
              })
          }
          .width('90%')
          .margin({ bottom: 8 })

          // æ§åˆ¶æŒ‰é’®ç¬¬ä¸‰è¡Œï¼ˆå¤–éƒ¨æ˜¾ç¤ºå™¨ï¼‰
          if (this.hasExternalDisplay) {
            Button(this.isOutputToExternal ? 'ğŸ”´ åœæ­¢çœ¼é•œè¾“å‡º' : 'ğŸ¥½ è¾“å‡ºåˆ°çœ¼é•œ')
              .fontSize(13)
              .height(40)
              .width('90%')
              .backgroundColor(this.isOutputToExternal ?
                'rgba(244, 67, 54, 0.8)' : 'rgba(0, 150, 136, 0.8)')
              .margin({ bottom: 8 })
              .onClick(() => this.toggleExternalOutput())
          }

          // å¤–éƒ¨æ˜¾ç¤ºå™¨ä¿¡æ¯
          Text(`å¤–éƒ¨æ˜¾ç¤ºå™¨: ${this.externalDisplayInfo}`)
            .fontSize(11)
            .fontColor('#546E7A')
            .margin({ bottom: 16 })
        }
        .width('100%')
        .padding({ bottom: 16 })
        .backgroundColor('rgba(0, 0, 0, 0.7)')
        .borderRadius({ topLeft: 20, topRight: 20 })
      }
      .width('100%')
      .height('100%')
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#000000')
  }
}
